from optparse import OptionParser
from optparse import SUPPRESS_HELP
#from ctypes import windll
import time
import re
import sys
import csv

TYPE_INT = 1
TYPE_STRING = 2
TYPE_BIT = 3
TYPE_INTARR = 4

class data_struct:
  error = 0
  def ds_print(self, cl):
    for const, cval in cl.consts.items():
      print "#define %25s %5d" % (const, cval)
    print ""
    print "struct %s {" % cl.name
    for t_var, tvars in sorted(cl.variables.items()):
      for var, s_var in sorted(tvars.items(), key=lambda x: x[1], reverse=True):
        print "  %10s %25s%s;" % (t_var, var, s_var[0])
    print "} __attribute__((packed));"
    print "#define %s_SIZEOF sizeof(struct %s)" % (cl.name.upper(), cl.name)

class csv2dat:
  error = 0

  def __init__(self, f):
    self.file = f

  def crc16(self, string, crc=0):
    for a in string:
      crc ^= a
      for i in range(8):
        if crc & 1:
          crc = (crc >> 1) ^ 0xA001
        else:
          crc = (crc >> 1)
    return crc

  def make_dat(self, cl):
    csvfile = open(self.file, 'rb')
    re_1 = re.compile(r'unused')
    csv_lines = 0
    data = {}
    if csvfile:
      reader = csv.reader(csvfile, delimiter=',', quotechar="'")
      re_int = re.compile(r'\d+')
      headers = reader.next()
      comment_line = reader.next()
      for h in headers:
        data[h] = []
      for row in reader:
        csv_lines += 1
        for h, v in zip(headers, row):
          data[h].append(v)
      ##
      vardict = {}
      goffset = 0
      for t_var, tvars in sorted(cl.variables.items()):
        for var, s_var in sorted(tvars.items(), key=lambda x: x[1][0], reverse=True):
          if re_1.match(var):
            pass
          elif var not in data:
            print "column '%s' not found in csv(%s)" % (var, self.file)
            self.error += 1
            return
          if int(((goffset+s_var[1]) * 10) % 10) > 8:
            goffset += 1
            goffset = int(goffset)
          s_var.append(goffset)
          assert var not in vardict
          vardict[var] = s_var
          goffset += s_var[1]
#          print "var:%s goffset:%f" % (var, goffset)
      ## Sanity check is complete, things should work from here
      outfile = open("%sdat" % self.file[:-3], 'wb')
      signature = 0
      assert(outfile)
#      pbytes = []
#      for i in range(1, -1, -1):
#        pbytes.append((csv_lines >> (i*8)) & 0xFF);
#      outfile.write(bytearray(pbytes))
#      signature = self.crc16(bytearray(pbytes), signature)
      re_graph = re.compile(r'[\x21-\x7E]')
      goffset += 0.9
      for li in range(csv_lines):
        pbytes = [0] * int(goffset)
        for var in vardict:
          offset = vardict[var][3]
          if options.debug:
            print "%s (TYPE:%d), offset : %f" % (var, vardict[var][2], offset)
          if var not in data:
            pass
          elif TYPE_INT == vardict[var][2]:
            for i in range(vardict[var][1]): ## each bytes
              if '' != data[var][li]:
                pbytes[vardict[var][3]+i] = (int(data[var][li]) >> (i*8)) & 0xFF
          elif TYPE_INTARR == vardict[var][2]:
            i,j,k,l = 0,0,0,0
            while ((i < vardict[var][1]) and (j < len(data[var][li]))): ## each bytes
              c = data[var][li][j]
              if re_graph.match(c):
                k <<= 4
                k |= int(c, 16)
                if (1 == (l&1)): ## assign
                  pbytes[vardict[var][3]+i] = k & 0xFF
                  i += 1
                l += 1
              j += 1
          elif TYPE_STRING == vardict[var][2]:
            for i in range(vardict[var][1]): ## each bytes
              if (i >= len(data[var][li])) or (not re_graph.match(data[var][li][i])):
                pbytes[vardict[var][3]+i] = ' '
              else:
                pbytes[vardict[var][3]+i] = data[var][li][i]
          elif TYPE_BIT == vardict[var][2]:
            if '' != data[var][li]:
#              print pbytes[int(vardict[var][3])], " ",
              pbytes[int(vardict[var][3])] |= int(data[var][li]) << (int((vardict[var][3]*10)%10))
#              print "TYPE_BIT ", var, ", ", int(vardict[var][3]), ", ", int(data[var][li]), ", ", (7 - int((vardict[var][3]*10)%10)),
#              print pbytes[int(vardict[var][3])]
          else: assert(0 == "Field '%s' is not type matched" % var)
        if options.debug: print "pbytes:", pbytes
        outfile.write(bytearray(pbytes))
        signature = self.crc16(bytearray(pbytes), signature)
      pbytes = []
      for i in range(1, -1, -1):
        pbytes.append((signature >> (i*8)) & 0xFF);
      outfile.write(bytearray(pbytes))
      outfile.close()
      csvfile.close()

  def make_csv(self, cl):
    datfile = open("%sdat" % self.file[:-3], 'rb')
    csvfile = open(self.file, 'wb')
    if datfile and csvfile:
      writer = csv.writer(csvfile, delimiter=',', quotechar="'")
      assert(0)
      datfile.close()
      csvfile.close()

class item:
  consts = {
    'ITEM_NAME_BYTEL':10,
    'ITEM_NAME_UNI_BYTEL':16,
    'ITEM_PROD_CODE_BYTEL':16,
    }
  variables = {
    'uint16_t' : {
      'id': ['', 2, TYPE_INT],
      'cost':['', 2, TYPE_INT],
      'discount':['', 2, TYPE_INT],
      },
    'uint8_t'  : {
      'name':['[ITEM_NAME_BYTEL]', 1*10, TYPE_STRING],
      'prod_code':['[ITEM_PROD_CODE_BYTEL]', 1*20, TYPE_STRING],
      'name_unicode':['[ITEM_NAME_UNI_BYTEL]', 1*18, TYPE_INTARR],
      'has_serv_tax':[':1', 0.1, TYPE_BIT],
      'has_common_discount':[':1', 0.1, TYPE_BIT],
      'has_cess1':[':1', 0.1, TYPE_BIT],
      'has_cess2':[':1', 0.1, TYPE_BIT],
      'has_weighing_mc':[':1', 0.1, TYPE_BIT],
      'vat_sel':[':2', 0.2, TYPE_BIT],
      'name_in_unicode':[':1', 0.1, TYPE_BIT],
      'unused_1':[':1', 0.1, TYPE_BIT],
      'unused_2':[':1', 0.1, TYPE_BIT],
      'unused_3':[':1', 0.1, TYPE_BIT],
      'unused_4':[':1', 0.1, TYPE_BIT],
      'unused_5':[':1', 0.1, TYPE_BIT],
      'unused_6':[':1', 0.1, TYPE_BIT],
      'unused_7':[':1', 0.1, TYPE_BIT],
      'is_disabled':[':1', 0.1, TYPE_BIT],
      }
    }

  def __init__(self, name):
    self.name = name

class ep_store_layout:
  consts = {
    'HEADER_SZ_MAX' : 16*3,
    'SHOP_SZ_MAX' : 16,
    'FOOTER_SZ_MAX' : 24,
    'EPS_MAX_VAT_CHOICE' : 8,
    'EPS_MAX_USERS' : 15,
    'EPS_MAX_UNAME' : 8,
    }
  variables = {
    'uint16_t' : {
      'vat' : ['[EPS_MAX_VAT_CHOICE]', 2*8, TYPE_INT],
      'service_tax' : ['', 2, TYPE_INT],
      'cess1' : ['', 2, TYPE_INT],
      'cess2' : ['', 2, TYPE_INT],
      'round_off' : ['', 2, TYPE_INT],
      ## bits [15:4] : Unused
      ## bits [3:0] : Printing
      ## value 0b0000 : don't ask, 0b00xx : copies without confirmation,
      ## 0b01xx : confirm before print xx copies
      'property' : ['', 2, TYPE_INT],
      'passwds' : ['[EPS_MAX_USERS+1]', 2*16, TYPE_INT],
      },
    'uint8_t' : {
      ## User options
      ## User 0 : is 'admin' + 15 usernames
      ## 16 passwords
      'users' : ['[EPS_MAX_USERS+1][EPS_MAX_UNAME]', 16*8, TYPE_STRING],
      'denomination_text' : ['[5]', 5, TYPE_STRING],
      'shop_name' : ['[SHOP_NAME_SZ_MAX]', 16, TYPE_STRING],
      'prn_header' : ['[HEADER_MAX_SZ_MAX]', 16*3, TYPE_STRING],
      'prn_footer' : ['[FOOTER_MAX_SZ_MAX]', 24, TYPE_STRING],
      }
    }
  def __init__(self, name):
    self.name = name

if "__main__" == __name__:
  ## Constants
  error = 0
  options = None

  ##
  parser = OptionParser()
  parser.add_option("", "--header",
                  action="store_true", dest="header", default=False,
                  help=SUPPRESS_HELP);
  parser.add_option("", "--debug",
                  action="store_true", dest="debug", default=False,
                  help=SUPPRESS_HELP);
  parser.add_option("", "--to_dat",
                  action="store_true", dest="to_dat", default=False,
                  help="Create csv file from dat");
  parser.add_option("", "--to_csv",
                  action="store_true", dest="to_csv", default=False,
                  help="Create dat file from csv");
  parser.add_option("-f", "--file", dest="csv", default="settings.csv",
                  help="Settings file");
  (options, args) = parser.parse_args()

  it = item('item')
  ep = ep_store_layout('ep_store_layout')

  if options.header:
    print "#ifndef EP_DS_H\n#define EP_DS_H\n"
    ds = data_struct()
    ds.ds_print(it)
    ds.ds_print(ep)
    print "\n\n#endif"
    error += ds.error
  elif options.to_dat:
    cd = csv2dat(options.csv)
    cd.make_csv(it)
    error += cd.error
  elif options.to_csv:
    cd = csv2dat(options.csv)
    cd.make_dat(it)
    error += cd.error
  else: error += 1

  sys.exit (error)
